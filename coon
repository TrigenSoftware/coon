#!/usr/bin/env node

// coon [add [site name] [ssh host] [ssh user] [ssh password] [ssh port] [path in repo] [path on server]]
// coon [bind <site name> [to <branch>]]  

"use strict";

// require
var sys = require("util"),
    fs = require("fs"),
    path = require("path"),
    ssh = require("ssh2"),
    git = require("git-info"),
    cs = require("colors"),
    sh = require("shelljs"),
    fe = require('forever-monitor');

var readline = require('readline')
    .createInterface({
        input: process.stdin,
        output: process.stdout
    }),
    args = process.argv;

// some data
var keys = {
    NAME: 0,
    SSH_HOST: 1,
    SSH_USER: 2,
    SSH_PKP: 3,
    SSH_PORT: 4,
    TIMEOUT: 5,
    DEPLOY: 6,
    BRANCH: 7,
    REPO_DIR: 8,
    SERVER_PATH: 9
};

var addWizard = [
    ["Config name: ", false],
    ["SSH host: ", false],
    ["SSH user: ", false],
    ["Path to SSH private key: ", false],
    ["SSH port (22 by default): ", 22],
    ["Deploy timout (10 sec by default): ", 10],
    ["Additional deploy command (empty by default): ", ""],
    ["Branch to observe (master by default): ", "master"],
    ["Dir in repo (. by default): ", "."],
    ["Path on server (. by default): ", "."]
];

var editWizard = [
    ["Config name (%def): ", false],
    ["SSH host (%def): ", false],
    ["SSH user (%def): ", false],
    ["Path to SSH private key (%def): ", false],
    ["SSH port (%def): ", 22],
    ["Deploy timout (%def sec): ", 10],
    ["Additional deploy command (%def): ", ""],
    ["Branch to observe (%def): ", "master"],
    ["Dir in repo (%def): ", "."],
    ["Path on server (%def): ", "."]
];

// hook
if(!sh.test('-e', process.cwd() + "/.git/hooks")) sh.mkdir(process.cwd() + "/.git/hooks");
var hookScript = sh.test('-e', process.cwd() + "/.git/hooks/pre-push") ? sh.cat(process.cwd() + "/.git/hooks/pre-push") : "#!/bin/sh\n\n";

function hooks_Save() {
    hookScript.to(process.cwd() + "/.git/hooks/pre-push");
    sh.exec("chmod +x " + process.cwd() + "/.git/hooks/pre-push");
}

function hooks_Add(conf){
    hooks_Remove(conf, true);
    hookScript += "# deploy " + conf[keys.NAME] + " with " + conf[keys.BRANCH] + "\n~/github/coon/coon delay-deploy \"" + conf[keys.NAME] + "\" with \"" + conf[keys.BRANCH] + "\"\n";
    hooks_Save();
}

function hooks_Remove(conf, withBranch){
    if(!withBranch){
        hookScript = hookScript.replace(new RegExp("# deploy " + conf[keys.NAME] + " with [^\\n]+\n[^\\n]+\n", "g"), "");
    } else {
        hookScript = hookScript.replace(new RegExp("# deploy " + conf[keys.NAME] + " with " + conf[keys.BRANCH] + "\n[^\\n]+\n", "g"), "");
    }
    hooks_Save();
}

// configs
var configsData = sh.test('-e', process.cwd() + "/.git/coon.json") ? JSON.parse(sh.cat(process.cwd() + "/.git/coon.json")) : {};

function configs_Save() {
    JSON.stringify(configsData).to(process.cwd() + "/.git/coon.json");
}

function configs_AddConfig(data, oldname) {
    if (oldname) delete configsData[oldname];
    configsData[data[0]] = data;

    console.log("\nüçª  " + "Config `".green + data[0] + (oldname ? "` updated." : "` added.").green);

    configs_Save();
    readline.close();
    process.exit();
}

function configs_Remove(name) {
    if (!configsData[name]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + name + "` doesn't exist.".red);
        process.exit();
    }

    delete configsData[name];
    console.log("üçª  " + "Config `".green + name + "` removed.".green);

    configs_Save();
    readline.close();
    process.exit();
}

function configs_List() {
    var list = "";
    for (var name in configsData) list += name.green + ", ";

    if (list.length == 0) console.log("Empty.".green);
    else console.log(list.replace(/, $/, "") + ".");

    process.exit();
}

function configs_Show(name) {
    if (!configsData[name]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + name + "` doesn't exist.".red);
        process.exit();
    }

    var conf = configsData[name],
        out = "";
    editWizard.forEach(function(wiz, i) {
        out += wiz[0].replace(" (%def)", "").green + conf[i] + "\n";
    });

    console.log(out);
    process.exit();
}

// helpers
function startAddWizard(i) {
    function addWizardQuest() {
        readline.question(addWizard[i][0], function(answer) {
            if (addWizard[i][1] === false && !answer) {
                addWizardQuest(i);
                return;
            } else if (addWizard[i][1] && !answer) answer = addWizard[i][1];
            siteData[i] = answer.replace("\"", "\\\"");

            if (i == addWizard.length - 1) configs_AddConfig(siteData);
            else addWizardQuest(i++);
        });
    }

    addWizardQuest();
}

function startEditWizard(configname) {
    if (!configsData[configname]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + configname + "` doesn't exist.".red);
        process.exit();
    }

    var siteData = configsData[configname],
        i = 0,
        name = siteData[0];

    function editWizardQuest() {
        readline.question(editWizard[i][0].replace("%def", siteData[i]), function(answer) {
            if (answer) siteData[i] = answer.replace("\"", "\\\"");

            if (i == editWizard.length - 1) configs_AddConfig(siteData, name);
            else editWizardQuest(i++);
        });
    }

    editWizardQuest();
}

function remoteExec(conn, command, cb){
    conn.exec(command, function(err, stream) {
        if (err) {
            throw err;
            process.exit();
        }

        stream.on('data', function(data) {
            console.log(data + "");
        }).on('close', function() {
            cb();
        }).stderr.on('data', function(data) {
            console.log("‚ùóÔ∏è  " + (data + "").red);
            process.exit();
        });
    });
}

function remoteExecQueue(conf, commands, cb){
    var conn = new ssh();
    conn.on('ready', function() {
        var i = 0;

        function rec(data){
            if(i == commands.length) return conn.end(), cb();
            console.log("=> " + commands[i].cyan);
            remoteExec(conn, commands[i++], rec);
        }

        rec();
    }).connect({
        host: conf[keys.SSH_HOST],
        port: conf[keys.SSH_PORT],
        username: conf[keys.SSH_USER],
        privateKey: require('fs').readFileSync(conf[keys.SSH_PKP].replace("~", process.env.HOME + "/"), "utf8")
    });
}

// go

if (!sh.test('-e', process.cwd() + "/.git")) {
    console.log("‚ùóÔ∏è  " + "You not in git repo.".red);
    process.exit();
}

args.splice(0, 2);

if (args[0] == "add") {
    var siteData = [];

    args.splice(0, 1);
    args.forEach(function(arg, i) {
        if (i >= addWizard.length) {
            console.log("‚ùóÔ∏è  " + "Too many arguments.".red);
            process.exit();
        }
        siteData.push(arg);
    });

    if (siteData.length < addWizard.length)
        startAddWizard(siteData.length);
}

if (args[0] == "edit") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    if (args.length > 2) {
        console.log("‚ùóÔ∏è  " + "Too many arguments.".red);
        process.exit();
    }

    startEditWizard(args[1]);
}

if (args[0] == "remove") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    if (args.length > 2) {
        console.log("‚ùóÔ∏è  " + "Too many arguments.".red);
        process.exit();
    }

    configs_Remove(args[1]);
}

if (args[0] == "configs" || args[0] == "binders") {
    if (args.length > 2) {
        console.log("‚ùóÔ∏è  " + "Too many arguments.".red);
        process.exit();
    }

    if(args[1] != "list"){ 
        console.log("‚ùóÔ∏è  " + "Invalid command.".red);
        process.exit();
    }

    if(args[0] == "configs") configs_List();
    else {
        console.log(hookScript);
        process.exit();
    }
}

if (args[0] == "show") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    configs_Show(args[1]);
}

if (args[0] == "bind") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    if (!configsData[args[1]]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + args[1] + "` doesn't exist.".red);
        process.exit();
    }

    var conf = configsData[args[1]].slice();

    if (args[2]) {
        if (args[2] != "with") {
            console.log("‚ùóÔ∏è  " + "Unknown command `".red + args[2] + "`.".red);
            process.exit();
        }

        if (!args[3]) {
            console.log("‚ùóÔ∏è  " + "You should write branch name.".red);
            process.exit();
        }

        conf[keys.BRANCH] = args[3];
    }

    hooks_Add(conf);
    console.log("üçª  " + "Config `".green + conf[keys.NAME] + "` binded to the `".green + conf[keys.BRANCH] + "` branch.".green);
    process.exit();
}

if (args[0] == "unbind") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    if (!configsData[args[1]]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + args[1] + "` doesn't exist.".red);
        process.exit();
    }

    var conf = configsData[args[1]].slice(), withBranch = false;

    if (args[2]) {
        if (args[2] != "from") {
            console.log("‚ùóÔ∏è  " + "Unknown command `".red + args[2] + "`.".red);
            process.exit();
        }

        if (!args[3]) {
            console.log("‚ùóÔ∏è  " + "You should write branch name.".red);
            process.exit();
        }

        conf[keys.BRANCH] = args[3];
        withBranch = true;
    }

    hooks_Remove(conf, withBranch);
    if(withBranch) console.log("üçª  " + "Config `".green + conf[keys.NAME] + "` unbinded from the `".green + conf[keys.BRANCH] + "` branch.".green);
    else console.log("üçª  " + "Config `".green + conf[keys.NAME] + "` unbinded from the repo.".green);
    process.exit();
}

if (args[0] == "deploy" || args[0] == "delay-deploy") {
    if (!args[1]) {
        console.log("‚ùóÔ∏è  " + "You should write config name.".red);
        process.exit();
    }

    if (!configsData[args[1]]) {
        console.log("‚ùóÔ∏è  " + "Config with name `".red + args[1] + "` doesn't exist.".red);
        process.exit();
    }

    var conf = configsData[args[1]].slice();

    if (args[2]) {
        if (args[2] != "with") {
            console.log("‚ùóÔ∏è  " + "Unknown command `".red + args[2] + "`.".red);
            process.exit();
        }

        if (!args[3]) {
            console.log("‚ùóÔ∏è  " + "You should write branch name.".red);
            process.exit();
        }

        conf[keys.BRANCH] = args[3];
    }

    if(args[0] == "delay-deploy"){
        (new (fe.Monitor)('delay-deploy.js', {
            max: 3,
            silent: true,
            options: args
        })).start();

        process.exit();
    }

    git(["repository", "branch"], function(err ,res){
        if (err) {
            console.log("‚ùóÔ∏è  " + "Something goes wrong.".red);
            process.exit();
        }

        if(conf[keys.DEPLOY].trim().length > 0){
            console.log("=> " + conf[keys.DEPLOY].trim().cyan);
            sh.exec(conf[keys.DEPLOY].trim());
        }

        var cmds = [
            "mkdir -p " + conf[keys.SERVER_PATH] + "/.coon-tmp",
            "git clone " + res.repository + " " + conf[keys.SERVER_PATH] + "/.coon-tmp/" + (conf[keys.NAME] + " " + conf[keys.BRANCH]).replace(/\s/g, "_"),
        ];

        if(conf[keys.BRANCH] != "master")
            cmds.push(
                "cd " + conf[keys.SERVER_PATH] + "/.coon-tmp/" + (conf[keys.NAME] + " " + conf[keys.BRANCH]).replace(/\s/g, "_") + " \n" +
                "   git checkout -b " + conf[keys.BRANCH]
            );

        cmds.push(
            "mv -f " + conf[keys.SERVER_PATH] + "/.coon-tmp/" + (conf[keys.NAME] + " " + conf[keys.BRANCH]).replace(/\s/g, "_") + "/* " + conf[keys.SERVER_PATH],
            "rm -rf " + conf[keys.SERVER_PATH] + "/.coon-tmp" 
        );

        remoteExecQueue(conf, cmds, function(){
            console.log("üçª  " + "`".green + conf[keys.BRANCH] + "` branch was successfully deployed on `".green + conf[keys.NAME] + "`.".green);
            process.exit();
        });
    });
}